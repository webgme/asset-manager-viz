/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Feb 23 2018 11:40:01 GMT-0600 (Central Standard Time).
 */

define([
    './CONSTANTS'
], function (CONSTANTS) {

    'use strict';

    function AssetManagerControl(options) {
        this.logger = options.logger.fork('Control');
        const logger = this.logger;
        this._client = options.client;
        const client = this._client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._widget.notifyUser = (msg) => {
            client.notifyUser(msg);
        };

        this._widget.addNewAttribute = (name, description, value) => {
            const attrName = `${CONSTANTS.ATTR_PREFIX}${name}`;

            if (!attrName || attrName.indexOf('.') > 0 || attrName.indexOf('$') > 0) {
                client.notifyUser({severity: 'error', message: 'Invalid attribute name, cannot contain . or $.'});
                return;
            }

            const nodeObj = client.getNode(CONSTANTS.NODE_ID);

            if (nodeObj) {

                client.startTransaction();

                try {
                    if (nodeObj.getValidAttributeNames().indexOf(attrName) > -1) {
                        throw new Error('Asset name is already taken, provide another one.');
                    }

                    client.setAttributeMeta(CONSTANTS.NODE_ID, attrName, {
                        type: 'asset',
                        hidden: true,
                        description: description || '',
                    });

                    if (value) {
                        client.setAttribute(CONSTANTS.NODE_ID, attrName, value);
                    }

                    client.notifyUser({severity: 'success',
                        message: 'Created new asset [' + name + '], edit content and description in table.'});
                } catch (err) {
                    logger.error(err);
                    client.notifyUser({severity: 'error', message: err.message});
                }

                client.completeTransaction();
            }
        };

        this._widget.updateAttributeDescription = (name, newDescription) => {
            try {
                const nodeObj = client.getNode(CONSTANTS.NODE_ID);
                const attrName = `${CONSTANTS.ATTR_PREFIX}${name}`;

                if (nodeObj) {
                    const attrDesc = nodeObj.getAttributeMeta(attrName);
                    attrDesc.description = newDescription;

                    client.setAttributeMeta(CONSTANTS.NODE_ID, `${CONSTANTS.ATTR_PREFIX}${name}`, attrDesc);
                }
            } catch (err) {
                logger.error(err);
                client.notifyUser({severity: 'error', message: err.message});
            }
        };

        this._widget.setAttributeAsset = (name, value) => {
            try {
                client.setAttribute(CONSTANTS.NODE_ID, `${CONSTANTS.ATTR_PREFIX}${name}`, value);
            } catch (err) {
                logger.error(err);
                client.notifyUser({severity: 'error', message: err.message});
            }
        };

        this._widget.renameAttribute = (name, newName) => {
            const attrName = `${CONSTANTS.ATTR_PREFIX}${name}`;
            const newAttrName = `${CONSTANTS.ATTR_PREFIX}${newName}`;
            const nodeObj = client.getNode(CONSTANTS.NODE_ID);

            if (!newName || newName.indexOf('.') > 0 || newName.indexOf('$') > 0) {
                client.notifyUser({severity: 'error', message: 'Invalid attribute name, cannot contain . or $.'});
                return;
            }

            if (nodeObj) {
                const attrDesc = nodeObj.getAttributeMeta(attrName);

                client.startTransaction();
                try {
                    if (nodeObj.getValidAttributeNames().indexOf(newAttrName) > -1) {
                        throw new Error('Asset name is already taken, provide another one.');
                    }
                    client.delAttributeMeta(CONSTANTS.NODE_ID, attrName);
                    client.setAttributeMeta(CONSTANTS.NODE_ID, newAttrName, attrDesc);
                    // TODO: Add this when the client has it on its API
                    // client.renameAttributeMeta(attrName, newAttrName);

                    client.renameAttribute(CONSTANTS.NODE_ID, attrName, newAttrName);
                }
                catch (err) {
                    logger.error(err);
                    client.notifyUser({severity: 'error', message: err.message});
                }

                client.completeTransaction();
            }
        };

        this._widget.deleteAttribute = (name) => {
            const attrName = `${CONSTANTS.ATTR_PREFIX}${name}`;

            client.startTransaction();

            try {
                client.delAttributeMeta(CONSTANTS.NODE_ID, attrName);
                client.delAttribute(CONSTANTS.NODE_ID, attrName);
            } catch (err) {
                logger.error(err);
                client.notifyUser({severity: 'error', message: err.message});
            }

            client.completeTransaction();
        };

        this._attributes = [];
        this._attributesCompare = JSON.stringify(this._attributes);

        this._uiId = this._client.addUI(null, (events) => {
            const nodeObj = client.getNode(CONSTANTS.NODE_ID);
            let newAttributes = [];

            if (nodeObj) {
                newAttributes = nodeObj.getValidAttributeNames()
                    .filter(attrName => attrName.startsWith(CONSTANTS.ATTR_PREFIX))
                    .sort()
                    .map((attrName) => {
                        return {
                            name: attrName.substring(CONSTANTS.ATTR_PREFIX.length),
                            value: nodeObj.getAttribute(attrName),
                            desc: nodeObj.getAttributeMeta(attrName)
                        }
                    });
            }

            // The widget takes care of only updating what changed..
            const newAttributesStr = JSON.stringify(newAttributes);

            if (this._attributesCompare !== newAttributesStr) {
                this._attributes = newAttributes;
                this._attributesCompare = newAttributesStr;
                this._widget.atNewAttributes(newAttributes);
            }
        });

        const territory = {};
        territory[CONSTANTS.NODE_ID] = {children: 0};

        client.updateTerritory(this._uiId, territory);
    }

    AssetManagerControl.prototype.onActivate = function () {
        this.logger.debug('AssetManagerWidget has been activated');
    };

    AssetManagerControl.prototype.onDeactivate = function () {
        this.logger.debug('AssetManagerWidget has been deactivated');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    AssetManagerControl.prototype.destroy = function () {
        this._client.removeUI(this._uiId);
    };

    return AssetManagerControl;
});
